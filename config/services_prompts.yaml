# DFM Prompt-bibliotek (services_prompts.yaml)

# --- Transformations-agenten (Ljud/Video) ---
transcriber:

# PASS 1: Rådatat (Ljud -> Text)
  pass1_raw: |
    Din uppgift är att transkribera ljudfilen ordagrant till svenska.
    
    INSTRUKTIONER:
    1. Skriv exakt vad som sägs, ord för ord.
    2. Använd generiska etiketter för talare: "Talare 1:", "Talare 2:", etc.
    3. Försök INTE gissa vem som är vem baserat på rösten.
    4. Gör INGA sammanfattningar.
    

  # PASS 2: Berikning & Analys (Text + Kontext -> Insikt)
  pass2_enriched: |
    {context_injection}

    Du har fått en rå transkription av ett möte eller en inspelning. Din uppgift är att tvätta, identifiera och berika texten med hjälp av kontexten ovan (om tillgänglig) eller innehållet.

    UTFÖR FÖLJANDE STEG:

    STEG 1: KVALITETSKONTROLL
    Analysera om råtexten är användbar.
    Returnera quality_status "FAILED" om texten är mestadels gibberish, upprepningar eller tekniska fel.
    
    STEG 2: BERIKAD TRANSKRIPTION (Om quality_status är "OK")
    Skriv om transkriptionen för maximal läsbarhet och tydlighet.
    
    A. TALARIDENTIFIERING:
       Använd "MÖTESKONTEXT" och "KÄNDA TALARE" för att ersätta "Talare 1" med riktiga namn.
       
    B. KONTEXTUELLA ANNOTERINGAR:
       När talare använder vaga ord ("det", "den", "projektet") och du vet vad som avses, skjut in en förklaring.
       Format: (Anm: förklaring)
       Exempel: "Vi måste fixa buggen i det (Anm: Inköpslänken) innan releasen."

    C. FORMATERING:
       Behåll dialogformatet "Namn: Text".

    STEG 3: METADATA EXTRAKTION
    Sammanfatta innehållet och extrahera metadata.
    
    - Titel: Om kontext finns (t.ex. "Budgetmöte"), använd den. Annars, skapa en kort, beskrivande titel baserat på innehållet.
    - Plats: Om kontext/innehåll nämner plats (t.ex. "Teams", "Konferensrummet"), ange det. Annars "Okänd".
    - Talare: Lista namn, och om möjligt Roll/Titel och Arbetsgivare baserat på kontexten/grafen.

    RETURNERA EXAKT DENNA JSON-STRUKTUR:
    {
      "quality_status": "OK" eller "FAILED",
      "failure_reason": "Endast vid FAILED",
      "title": "Kort beskrivande titel",
      "location": "Plats eller Okänd",
      "transcript": "Den berikade dialogen...",
      "summary": "Kortfattad sammanfattning av mötet",
      "speakers_detailed": [
        {"name": "Namn Efternamn", "role": "Titel/Roll", "org": "Organisation"}
      ],
      "keywords": ["tag1", "tag2"],
      "entities": ["Personer", "System", "Projekt"]
    }

# --- Doc Converter (Textfiler/Dokument) ---
doc_converter:
  doc_summary_prompt: |
    Sammanfatta detta dokument kortfattat och informativt på svenska.
    Fokusera på VAD det är, VEM det berör och VILKA beslut/händelser som nämns.

    TEXT:
    {text}

    RETURNERA JSON:
    {{
      "summary": "Din sammanfattning här...",
      "keywords": ["nyckelord1", "nyckelord2"]
    }}

  strict_entity_extraction: |
    Du är en expert på Knowledge Graph Extraction. Din uppgift är att strukturera ostrukturerad text till en graf bestående av Noder och Relationer, strikt baserat på det bifogade schemat.

    === DINA INSTRUKTIONER ===
    1. EXTRAHERA NODER:
    
    TILLÅTNA NODTYPER (OCH EGENSKAPER):
    Här är de enda nodtyper du får skapa. Observera särskilt vilka egenskaper och enum-värden som är tillåtna.
    {node_types_context}

      - Identifiera entiteter som matchar schemat.
      - Fyll i så många egenskaper som möjligt om informationen finns i texten.
      - Om en egenskap har en lista med tillåtna värden [Val1, Val2...], MÅSTE du använda ett av dessa exakt. Hitta inte på egna.
      - "confidence": Sätts baserat på "Schema-Fit" (0.0 - 1.0).
        * 0.8-1.0 (Hög): Entiteten uppfyller definitionen tydligt och har unika attribut.
        * <0.3 (Låg/Brus): Entiteten är generisk eller trivial.
      - "context_keywords": Lista 2-4 nyckelord som beskriver entitetens roll/kontext (för deduplicering). Detta fält är OBLIGATORISKT.
      - "status": Sätt ALLTID till "PROVISIONAL" (om det inte är ett Ankare som du återanvänder).
      
    
    2. ANKARE (Prioritet 1):
      - Kontrollera alltid listan "KÄNDA ENTITETER" om sådan finns.
      - Om texten nämner en entitet som matchar en känd entitet, MÅSTE du återanvända dess UUID exakt.
    
    3. SKAPA RELATIONER:
      - Identifiera kopplingar mellan noderna.
      - Skapa ENDAST relationstyper som existerar enligt TILLÅTNA RELATIONSTYPER nedan.
      - Koppla relationer ENDAST på det sätt som explicit framgår som tillåtet (Källa -> Mål).
    
    TILLÅTNA RELATIONSTYPER (WHITELIST):
    {edge_types_context}

    === KONTEXT FRÅN KÄLLAN ===
    {known_entities_context}

    RETURNERA JSON (Exakt format):
    {{
      "nodes": [
        {{ 
          "name": "Namn", 
          "type": "Nodtyp", 
          "properties": {{ "egenskap": "värde" }},  // OBS: I vår platta modell ligger egenskaperna direkt på roten, inte i ett properties-objekt.
          "org_type": "Bolag", // Exempel på egenskap
          "context_keywords": ["ord1", "ord2"], 
          "status": "PROVISIONAL",
          "confidence": 0.85
        }}
      ],
      "edges": [
        {{ "source": "Namn", "target": "Namn", "type": "RELATIONSTYP", "confidence": 0.9 }}
      ]
    }}

    TEXT ATT ANALYSERA:
    "{text_chunk}"


# --- Dreamer (Taxonomi-konsolidering) ---
dreamer:
  consolidation_prompt: |
    Du är en taxonomi-expert. Din uppgift är att kategorisera NYA noder under rätt masternode.
    
    BEFINTLIGA MASTERNODER (med beskrivningar):
    {master_nodes}
    
    NYA KONCEPT (okategoriserade):
    {new_concepts}
    
    NYA ENTITETER (per typ):
    {new_entities}
    
    INSTRUKTIONER:
    1. Placera varje nytt koncept under den MEST passande masternoden
    2. Använd EXAKT nodnamn från BEFINTLIGA MASTERNODER ovan som nycklar
    3. Om ett koncept är ett ALIAS för något som redan finns, lägg det i aliases_detected
    4. Var konsekvent - liknande koncept ska hamna under samma masternode
    5. VARJE koncept MÅSTE placeras under en masternode - ingen får utelämnas
    
    RETURNERA ENDAST GILTIG JSON. Exempel på korrekt format:
    {"Händelser": ["Sprint review", "Standup"], "Teknologier": ["Kubernetes"], "Person": ["Anna"], "aliases_detected": [{"alias": "K8s", "canonical": "Kubernetes", "confidence": "high"}]}
    
    Nycklar MÅSTE vara exakta nodnamn från BEFINTLIGA MASTERNODER. Inkludera INTE noder utan nya koncept.

# --- Entity Resolver (Dreamer: Dubblett-jakt) ---
entity_resolver:
  entity_resolution_prompt: |
    Du är en expert på Identity Resolution. Din uppgift är att avgöra om två noder (Node A och Node B) representerar SAMMA verkliga entitet.

    NODE A (Kandidat):
    {node_a_json}

    NODE B (Matchningsobjekt):
    {node_b_json}

    INSTRUKTIONER:
    1. Jämför namn, alias, typ och kontext.
    2. Ta hänsyn till stavfel, smeknamn (Jocke/Joakim) och namnvariationer (AB/Aktiebolag).
    3. Titta noga på 'context_keywords' om de finns - pekar de på samma roll/område?
    4. Om namnen är lika men kontexten är helt olika (t.ex. Jocke på IT vs Jocke på Sälj), är det INTE en match.
    
    BEDÖMNING:
    Returnera en JSON med:
    - "decision": "MERGE" (om det är samma), "IGNORE" (om olika/osäkert), "REVIEW" (om troligt men kräver människa).
    - "confidence": 0.0 - 1.0
    - "reason": Kort förklaring.

    RETURNERA ENDAST JSON:
    {{
      "decision": "MERGE",
      "confidence": 0.95,
      "reason": "Namnen är identiska och båda har kontexten 'IT-chef'."
    }}

  context_pruning_prompt: |
    Du ska städa upp en lista med nyckelord för en entitet.
    Ta bort dubbletter, synonymer och irrelevanta ord. Behåll de mest beskrivande.
    
    LISTA:
    {keywords}
    
    RETURNERA JSON:
    {{
      "pruned_keywords": ["ord1", "ord2"]
    }}