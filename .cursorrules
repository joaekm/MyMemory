# MyMemory Development Rules

## Princip 1: HARDFAIL > Silent Fallback

**Inga tysta fallbacks.** Om en operation misslyckas ska systemet:

1. **Rapportera felet explicit** till användaren
2. **Logga orsaken** med full kontext
3. **Avbryta operationen** istället för att gissa

### Varför?

- **Transparens:** Användaren ska veta varför något misslyckades
- **Debuggbarhet:** Tysta fallbacks maskerar buggar och gör dem svåra att hitta
- **Förtroende:** Bättre att säga "jag vet inte" än att ge ett dåligt svar

### Exempel på FEL (anti-pattern):

```python
# ❌ DÅLIGT: Tyst fallback
def search(query, strategy="STRICT"):
    results = strict_search(query)
    if not results:
        results = relaxed_search(query)  # Tyst fallback - användaren vet inte
    return results
```

### Exempel på RÄTT:

```python
# ✅ BRA: Explicit hardfail
def search(query, strategy="STRICT"):
    results = strict_search(query)
    if not results:
        return {
            "status": "NO_RESULTS",
            "reason": f"Strict search for '{query}' returned 0 hits",
            "suggestion": "Försök med bredare söktermer",
            "results": []
        }
    return {"status": "OK", "results": results}
```

### Undantag:

Fallbacks är tillåtna **endast** om:
1. De är **explicit dokumenterade** i svaret till användaren
2. De **loggas** med nivå WARNING eller högre
3. Användaren kan **se** att en fallback användes (t.ex. i debug_trace)

```python
# ✅ OK: Explicit fallback med transparens
if not results:
    logger.warning(f"STRICT search failed, using RELAXED fallback")
    results = relaxed_search(query)
    return {
        "status": "FALLBACK_USED",
        "fallback_reason": "Strict search returned 0 results",
        "results": results
    }
```

---

## Princip 2: Fail Fast, Fail Loud

- Validera input tidigt
- Kasta exceptions istället för att returnera None
- Logga ALLA fel, även "förväntade"

---

## Princip 3: Ingen AI-cringe

Undvik töntiga metafornamn i kod och dokumentation:
- ❌ "Trädgårdsmästaren", "Bibliotekarien", "Portvakten"
- ✅ "Konsolidering", "Vektorsökning", "Desktop-agent"

Behåll deskriptiva namn som faktiskt beskriver funktionen:
- ✅ "Jägaren" (keyword search) - acceptabelt
- ✅ "Domaren" (re-ranker) - acceptabelt

---

## Princip 4: Stanna vid Vägval

**Vid implementation, avbryt och fråga användaren vid:**

1. **Namngivning** - funktioner, variabler, fält
2. **Prompt-formuleringar** - AI-prompter är känsliga
3. **Output-format** - JSON-strukturer, API-kontrakt
4. **Trade-offs** - hastighet vs kvalitet, enkelhet vs flexibilitet
5. **Oklarheter** - om specifikationen är tvetydig

### Varför?

- Användaren är expert på sin domän
- Fel beslut tidigt = dyr refaktorering senare
- Bättre en fråga för mycket än fel antagande

### Exempel:

```
❌ DÅLIGT: 
"Jag valde att använda 'FACT' istället för 'STRICT' för intent-klassificering"

✅ BRA:
"VÄGVAL: Intent-klassificering. Förslag: 'STRICT' vs 'RELAXED'. 
Vad föredrar du?"
```

---

## Princip 5: Generella Lösningar på Specifika Problem

**Vid felsökning, sök den generella orsaken - inte den specifika symptomet.**

### Anti-pattern:

```
Problem: "Systemet tappar datum i svaren"
❌ DÅLIGT: "Lägg till instruktion i prompten: 'extrahera alltid datum'"

Problem: "Systemet hittar inte 'Cenk' när jag söker"  
❌ DÅLIGT: "Lägg till 'Cenk' som alias i konfigurationen"
```

### Rätt approach:

```
Problem: "Systemet tappar datum i svaren"
✅ BRA: "Varför tappar vi SPECIFIK information generellt?"
       → Analysera: Är det Planner som filtrerar bort? 
       → Är rapporten för kort? Fel urvalskriterier?
       → Generell lösning: Förbättra fakta-extraktion i Planner

Problem: "Systemet hittar inte 'Cenk' när jag söker"
✅ BRA: "Varför hittar vi inte varianter av namn generellt?"
       → Analysera: Saknar vi alias-hantering?
       → Generell lösning: Entity Resolution (OBJEKT-44)
```

### Varför?

- Specifika fixar skapar teknisk skuld och underhållskostnader
- Generella lösningar löser KLASSER av problem, inte instanser
- "Elegant" = En lösning som löser många problem samtidigt

---

## Princip 6: Inga Hårdkodade Promptar

**ALLA AI-promptar ska ligga i config-filer**, aldrig i Python-kod.

### Varför?

- **Separation of Concerns:** Kod och promptar har olika livscykler
- **Iterera snabbt:** Ändra promptar utan att röra kod
- **Versionhantering:** Se prompt-ändringar tydligt i git
- **Konsistens:** En plats för alla promptar

### Config-filer:

- `config/chat_prompts.yaml` - Promptar för chat-relaterade funktioner
- `config/services_prompts.yaml` - Promptar för tjänster (DocConverter, Transcriber, etc.)

### Exempel på FEL:

```python
# ❌ DÅLIGT: Hårdkodad prompt
def analyze(text):
    prompt = f"Analysera följande text och extrahera nyckelord: {text}"
    return ai_client.generate(prompt)
```

### Exempel på RÄTT:

```python
# ✅ BRA: Prompt från config
def analyze(text):
    prompt_template = PROMPTS.get('keyword_extractor', {}).get('instruction', '')
    if not prompt_template:
        raise ValueError("HARDFAIL: keyword_extractor prompt saknas i config")
    prompt = prompt_template.format(text=text)
    return ai_client.generate(prompt)
```

---

## Princip 7: Taxonomin är Master

**`~/MyMemory/Index/my_mem_taxonomy.json` är källan till sanning för kategorier.**

### Regler:

1. **ALDRIG hårdkoda kategorier** i kod (persons, organizations, projects, etc.)
2. **LÄS alltid** från taxonomin vid uppstart eller vid behov
3. Taxonomins huvudnoder definierar tillåtna kategorier för:
   - Entity types i `entity_register.py`
   - Graph-noder i `my_mem_graph_builder.py`
   - Metadata-klassificering i alla agenter

### Taxonomins struktur:

```
~/MyMemory/Index/my_mem_taxonomy.json
├── Person      → entitetstyp för personer
├── Aktör       → entitetstyp för organisationer
├── Projekt     → entitetstyp för projekt
├── Teknologier → entitetstyp för produkter/verktyg
├── Erbjudande  → entitetstyp för tjänster
└── ... (22+ huvudnoder)
```

### Varför?

- Taxonomin är definierad av användaren, inte av koden
- Nya kategorier kan läggas till utan kodändringar
- Konsistens över hela systemet
- Undviker duplicering av kategoridefinitioner

### Exempel på FEL:

```python
# ❌ DÅLIGT: Hårdkodade kategorier
VALID_ENTITY_TYPES = ["persons", "organizations", "projects"]
```

### Exempel på RÄTT:

```python
# ✅ BRA: Läs från taxonomin
TAXONOMY_PATH = os.path.expanduser("~/MyMemory/Index/my_mem_taxonomy.json")

def _load_taxonomy_categories():
    with open(TAXONOMY_PATH, 'r') as f:
        return list(json.load(f).keys())

VALID_ENTITY_TYPES = _load_taxonomy_categories()
```

---

## Princip 8: Config är Sanning för Sökvägar

**ALLA sökvägar ska läsas från `config/my_mem_config.yaml`**, aldrig hårdkodas i kod.

### Varför?

- **En källa till sanning:** Ändra sökväg på ett ställe
- **Miljöoberoende:** Fungerar på olika maskiner utan kodändringar
- **Transparens:** Alla sökvägar är dokumenterade och synliga

### Config-sökvägar (my_mem_config.yaml):

```yaml
paths:
  drop_folder: "~/Desktop/MemoryDrop"
  lake_store: "~/MyMemory/Lake"
  asset_store: "~/MyMemory/Assets"
  chroma_db: "~/MyMemory/Index/ChromaDB"
  kuzu_db: "~/MyMemory/Index/KuzuDB"
  taxonomy_file: "~/MyMemory/Index/my_mem_taxonomy.json"
```

### Exempel på FEL:

```python
# ❌ DÅLIGT: Hårdkodad sökväg
KUZU_PATH = os.path.expanduser("~/MyMemory/Index/my_mem_kuzu")
LAKE_PATH = "/Users/jekman/MyMemory/Lake"
```

### Exempel på RÄTT:

```python
# ✅ BRA: Läs från config
CONFIG = load_config('my_mem_config.yaml')
KUZU_PATH = os.path.expanduser(CONFIG['paths']['kuzu_db'])
LAKE_PATH = os.path.expanduser(CONFIG['paths']['lake_store'])
```
