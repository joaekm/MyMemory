# MyMemory Development Rules

## Princip 1: HARDFAIL > Silent Fallback

**Inga tysta fallbacks.** Om en operation misslyckas ska systemet:

1. **Rapportera felet explicit** till användaren
2. **Logga orsaken** med full kontext
3. **Avbryta operationen** istället för att gissa

### Varför?

- **Transparens:** Användaren ska veta varför något misslyckades
- **Debuggbarhet:** Tysta fallbacks maskerar buggar och gör dem svåra att hitta
- **Förtroende:** Bättre att säga "jag vet inte" än att ge ett dåligt svar

### Exempel på FEL (anti-pattern):

```python
# ❌ DÅLIGT: Tyst fallback
def search(query, strategy="STRICT"):
    results = strict_search(query)
    if not results:
        results = relaxed_search(query)  # Tyst fallback - användaren vet inte
    return results
```

### Exempel på RÄTT:

```python
# ✅ BRA: Explicit hardfail
def search(query, strategy="STRICT"):
    results = strict_search(query)
    if not results:
        return {
            "status": "NO_RESULTS",
            "reason": f"Strict search for '{query}' returned 0 hits",
            "suggestion": "Försök med bredare söktermer",
            "results": []
        }
    return {"status": "OK", "results": results}
```

### Undantag:

Fallbacks är tillåtna **endast** om:
1. De är **explicit dokumenterade** i svaret till användaren
2. De **loggas** med nivå WARNING eller högre
3. Användaren kan **se** att en fallback användes (t.ex. i debug_trace)

```python
# ✅ OK: Explicit fallback med transparens
if not results:
    logger.warning(f"STRICT search failed, using RELAXED fallback")
    results = relaxed_search(query)
    return {
        "status": "FALLBACK_USED",
        "fallback_reason": "Strict search returned 0 results",
        "results": results
    }
```

---

## Princip 2: Fail Fast, Fail Loud

- Validera input tidigt
- Kasta exceptions istället för att returnera None
- Logga ALLA fel, även "förväntade"

---

## Princip 3: Ingen AI-cringe

Undvik töntiga metafornamn i kod och dokumentation:
- ❌ "Trädgårdsmästaren", "Bibliotekarien", "Portvakten"
- ✅ "Konsolidering", "Vektorsökning", "Desktop-agent"

Behåll deskriptiva namn som faktiskt beskriver funktionen:
- ✅ "Jägaren" (keyword search) - acceptabelt
- ✅ "Domaren" (re-ranker) - acceptabelt

---

## Princip 4: Stanna vid Vägval

**Vid implementation, avbryt och fråga användaren vid:**

1. **Namngivning** - funktioner, variabler, fält
2. **Prompt-formuleringar** - AI-prompter är känsliga
3. **Output-format** - JSON-strukturer, API-kontrakt
4. **Trade-offs** - hastighet vs kvalitet, enkelhet vs flexibilitet
5. **Oklarheter** - om specifikationen är tvetydig

### Varför?

- Användaren är expert på sin domän
- Fel beslut tidigt = dyr refaktorering senare
- Bättre en fråga för mycket än fel antagande

### Exempel:

```
❌ DÅLIGT: 
"Jag valde att använda 'FACT' istället för 'STRICT' för intent-klassificering"

✅ BRA:
"VÄGVAL: Intent-klassificering. Förslag: 'STRICT' vs 'RELAXED'. 
Vad föredrar du?"
```

---

## Princip 5: Generella Lösningar på Specifika Problem

**Vid felsökning, sök den generella orsaken - inte den specifika symptomet.**

### Anti-pattern:

```
Problem: "Systemet tappar datum i svaren"
❌ DÅLIGT: "Lägg till instruktion i prompten: 'extrahera alltid datum'"

Problem: "Systemet hittar inte 'Cenk' när jag söker"  
❌ DÅLIGT: "Lägg till 'Cenk' som alias i konfigurationen"
```

### Rätt approach:

```
Problem: "Systemet tappar datum i svaren"
✅ BRA: "Varför tappar vi SPECIFIK information generellt?"
       → Analysera: Är det Planner som filtrerar bort? 
       → Är rapporten för kort? Fel urvalskriterier?
       → Generell lösning: Förbättra fakta-extraktion i Planner

Problem: "Systemet hittar inte 'Cenk' när jag söker"
✅ BRA: "Varför hittar vi inte varianter av namn generellt?"
       → Analysera: Saknar vi alias-hantering?
       → Generell lösning: Entity Resolution (OBJEKT-44)
```

### Varför?

- Specifika fixar skapar teknisk skuld och underhållskostnader
- Generella lösningar löser KLASSER av problem, inte instanser
- "Elegant" = En lösning som löser många problem samtidigt

